def binary_search(arr: list, target: float):
    """
    Виконує двійковий пошук для відсортованого масиву з дробовими числами, який повертає
    кортеж з кількістю ітерацій та верхньою межею (найменший елемент, більший або рівний цільовому значенню).
    """
    left, right = 0, len(arr) - 1         # Ініціалізуємо початкові індекси для лівої та правої меж масиву
    iterations = 0                        # Лічильник кількості ітерацій
    upper_bound = None                    # Змінна для збереження верхньої межі

    while left <= right:
        iterations += 1
        mid = (left + right) // 2         # Oбчислення середнього значення
        if arr[mid] == target:            # Якщо середній елемент дорівнює цільовому значенню
            return (iterations, arr[mid]) # Повертаємо кількість ітерацій і знайдений елемент
        elif arr[mid] < target:           # Якщо середній елемент менший за цільове значення
            left = mid + 1                # Зсуваємо ліву межу вправо, виключаючи середній елемент
        else:                             # Якщо середній елемент більший за цільове значення
            upper_bound = arr[mid]        # Зберігаємо середній елемент як потенційну верхню межу
            right = mid - 1               # Зсуваємо праву межу вліво, виключаючи середній елемент

    return (iterations, upper_bound)      # Повертаємо кількість ітерацій і верхню межу

# Приклади використання:
arrays = [
    ([1.1, 2.2, 3.3, 4.4, 5.5], 3.5),  # Стандартний випадок
    ([], 3.5),                         # Порожній масив
    ([1.1, 2.2, 3.3, 4.4, 5.5], 6.0),  # Ціль більше за всі елементи
    ([1.1, 2.2, 3.3, 4.4, 5.5], 0.5),  # Ціль менше за всі елементи
    ([1.1, 2.2, 3.3, 4.4, 5.5], 3.3)   # Ціль дорівнює пошуковому елементу
]

for arr, target in arrays:
    result = binary_search(arr, target)
    print(f"Масив: {arr}, Ціль: {target}, Кількість ітерацій: {result[0]}, Верхня межа: {result[1]}")